local ui = game:GetService("CoreGui"):FindFirstChild("GYATNOTIF")
if ui then ui:Destroy() end

local TweenService = game:GetService("TweenService");
local RunService = game:GetService("RunService");
local TextService = game:GetService("TextService");

local Player = game:GetService("Players").LocalPlayer;

local NotifGui = Instance.new("ScreenGui");
NotifGui.Name = "GYATNOTIF";
NotifGui.IgnoreGuiInset = true
NotifGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
NotifGui.Parent = RunService:IsStudio() and Player.PlayerGui or game:GetService("CoreGui");

local Container = Instance.new("Frame");
Container.Name = "Container";
Container.Position = UDim2.new(0, 1600, 0.3, -20);
Container.Size = UDim2.new(0, 320, 0.5, 0);
Container.BackgroundTransparency = 1;
Container.Parent = NotifGui;

-- utility
local function Image(ID, Button)
	local NewImage = Instance.new(string.format("Image%s", Button and "Button" or "Label"));
	NewImage.Image = ID;
	NewImage.BackgroundTransparency = 1;
	NewImage.ZIndex = 2
	return NewImage;
end

-- rounded panel with gradient
local function Round2px()
	local NewImage = Image("http://www.roblox.com/asset/?id=5761488251");
	NewImage.ScaleType = Enum.ScaleType.Slice;
	NewImage.SliceCenter = Rect.new(2, 2, 298, 298);
	NewImage.ImageColor3 = Color3.fromRGB(25, 25, 25);

	local Gradient = Instance.new("UIGradient");
	Gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(40,40,40)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(20,20,20))
	}
	Gradient.Rotation = 90;
	Gradient.Parent = NewImage;

	local Corner = Instance.new("UICorner");
	Corner.CornerRadius = UDim.new(0, 8);
	Corner.Parent = NewImage;

	local Stroke = Instance.new("UIStroke");
	Stroke.Color = Color3.fromRGB(60,60,60)
	Stroke.Thickness = 1
	Stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	Stroke.Parent = NewImage

	return NewImage;
end

-- shadow
local function Shadow2px()
	local NewImage = Image("http://www.roblox.com/asset/?id=5761498316");
	NewImage.ScaleType = Enum.ScaleType.Slice;
	NewImage.SliceCenter = Rect.new(17, 17, 283, 283);
	NewImage.Size = UDim2.fromScale(1, 1) + UDim2.fromOffset(40, 40);
	NewImage.Position = -UDim2.fromOffset(20, 20);
	NewImage.ImageColor3 = Color3.fromRGB(0, 0, 0);
	NewImage.ImageTransparency = 0.6;
	NewImage.ZIndex = 1
	return NewImage;
end

-- settings
local Padding = 6;
local DescriptionPadding = 12;
local InstructionObjects = {};
local TweenTime = 1;
local TweenStyle = Enum.EasingStyle.Sine;
local TweenDirection = Enum.EasingDirection.Out;

local LastTick = tick();

local function CalculateBounds(TableOfObjects)
	local TableOfObjects = typeof(TableOfObjects) == "table" and TableOfObjects or {};
	local X, Y = 0, 0;
	for _, Object in next, TableOfObjects do
		X += Object.AbsoluteSize.X;
		Y += Object.AbsoluteSize.Y;
	end
	return {X = X, Y = Y, x = X, y = Y};
end

local CachedObjects = {};

-- update animation loop
local function Update()
	local DeltaTime = tick() - LastTick;
	local PreviousObjects = {};
	for CurObj, Object in next, InstructionObjects do
		local Label, Delta, Done = Object[1], Object[2], Object[3];
		if (not Done) then
			if (Delta < TweenTime) then
				Object[2] = math.clamp(Delta + DeltaTime, 0, 1);
				Delta = Object[2];
			else
				Object[3] = true;
			end
		end
		local NewValue = TweenService:GetValue(Delta, TweenStyle, TweenDirection);
		local CurrentPos = Label.Position;
		local PreviousBounds = CalculateBounds(PreviousObjects);
		local TargetPos = UDim2.new(0, 0, 0, PreviousBounds.Y + (Padding * #PreviousObjects));
		Label.Position = CurrentPos:Lerp(TargetPos, NewValue);
		table.insert(PreviousObjects, Label);
	end
	CachedObjects = PreviousObjects;
	LastTick = tick();
end

RunService:BindToRenderStep("UpdateList", 0, Update);

-- text settings
local TitleSettings = {
	Font = Enum.Font.GothamBold;
	Size = 16;
}

local DescriptionSettings = {
	Font = Enum.Font.Gotham;
	Size = 14;
	Color = Color3.fromRGB(220,220,220);
}

local MaxWidth = (Container.AbsoluteSize.X - Padding - DescriptionPadding);

-- text creator
local function Label(Text, Font, Size, Button)
	local Label = Instance.new(string.format("Text%s", Button and "Button" or "Label"));
	Label.Text = Text;
	Label.Font = Font;
	Label.TextSize = Size;
	Label.BackgroundTransparency = 1;
	Label.TextXAlignment = Enum.TextXAlignment.Left;
	Label.RichText = true;
	Label.TextColor3 = Color3.fromRGB(255, 255, 255);
	Label.ZIndex = 3
	return Label;
end

local function TitleLabel(Text)
	return Label(Text, TitleSettings.Font, TitleSettings.Size);
end

local function DescriptionLabel(Text)
	local L = Label(Text, DescriptionSettings.Font, DescriptionSettings.Size);
	L.TextColor3 = DescriptionSettings.Color
	return L
end

-- fade system
local PropertyTweenOut = {
	Text = "TextTransparency",
	Fram = "BackgroundTransparency",
	Imag = "ImageTransparency"
}

local function FadeProperty(Object)
	local Prop = PropertyTweenOut[string.sub(Object.ClassName, 1, 4)];
	if not Prop then return end
	TweenService:Create(Object, TweenInfo.new(0.25, TweenStyle, TweenDirection), {
		[Prop] = 1;
	}):Play();
end

local function SearchTableFor(Table, For)
	for _, v in next, Table do
		if (v == For) then
			return true;
		end
	end
	return false;
end

local function FindIndexByDependency(Table, Dependency)
	for Index, Object in next, Table do
		if (typeof(Object) == "table") then
			local Found = SearchTableFor(Object, Dependency);
			if (Found) then
				return Index;
			end
		else
			if (Object == Dependency) then
				return Index;
			end
		end
	end
end

local function ResetObjects()
	for _, Object in next, InstructionObjects do
		Object[2] = 0;
		Object[3] = false;
	end
end

local function FadeOutAfter(Object, Seconds)
	task.wait(Seconds);
	FadeProperty(Object);
	for _, SubObj in next, Object:GetDescendants() do
		FadeProperty(SubObj);
	end
	task.wait(0.25);
	table.remove(InstructionObjects, FindIndexByDependency(InstructionObjects, Object));
	ResetObjects();
end

-- public API
return {
	Notify = function(Properties)
		local Properties = typeof(Properties) == "table" and Properties or {};
		local Title = Properties.Title;
		local Description = Properties.Description;
		local Duration = Properties.Duration or 5;
		local Icon = Properties.Icon -- optional

		if (Title) or (Description) then
			local Y = Title and 26 or 0;
			if (Description) then
				local TextSize = TextService:GetTextSize(Description, DescriptionSettings.Size, DescriptionSettings.Font, Vector2.new(0, 0));
				for i = 1, math.ceil(TextSize.X / MaxWidth) do
					Y += TextSize.Y;
				end
				Y += 8;
			end

			local NewLabel = Round2px();
			NewLabel.Size = UDim2.new(1, 0, 0, Y + 10);
			NewLabel.Position = UDim2.new(-10, 20, 0, CalculateBounds(CachedObjects).Y + (Padding * #CachedObjects));

			if (Title) then
				local NewTitle = TitleLabel(Title);
				NewTitle.Size = UDim2.new(1, -10, 0, 26);
				NewTitle.Position = UDim2.fromOffset(Icon and 36 or 10, 2);
				NewTitle.Parent = NewLabel;
			end
			if (Description) then
				local NewDescription = DescriptionLabel(Description);
				NewDescription.TextWrapped = true;
				NewDescription.Size = UDim2.fromScale(1, 1) + UDim2.fromOffset(-(DescriptionPadding + (Icon and 26 or 0)), Title and -26 or 0);
				NewDescription.Position = UDim2.fromOffset(Icon and 36 or 10, Title and 26 or 0);
				NewDescription.TextYAlignment = Enum.TextYAlignment[Title and "Top" or "Center"];
				NewDescription.Parent = NewLabel;
			end
			if Icon then
				local IconImg = Image(Icon);
				IconImg.Size = UDim2.fromOffset(22,22);
				IconImg.Position = UDim2.fromOffset(8, 6);
				IconImg.ZIndex = 3
				IconImg.Parent = NewLabel
			end

			Shadow2px().Parent = NewLabel;
			NewLabel.Parent = Container;

			table.insert(InstructionObjects, {NewLabel, 0, false});
			coroutine.wrap(FadeOutAfter)(NewLabel, Duration);
		end
	end,
}
